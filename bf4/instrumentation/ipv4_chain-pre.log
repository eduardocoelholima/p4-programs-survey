@noremove() type bit<12> packet_model;
extern void modelPeek<H>(in packet_model self, out H ret_);
extern void modelPop<H>(in packet_model self, out packet_model self_out, out H ret_);
extern void modelAdvance(in packet_model self, out packet_model self_out, in int by);
extern void modelEmit<H>(in packet_model self, out packet_model self_out, in H h);
extern void modelZero(out packet_model self);
extern void modelPrepend(in packet_model self, out packet_model self_out, in packet_model h);
extern void modelCopy(in packet_model from, out packet_model to);
extern void havoc<H>(out H ret_);
extern void assert(in bool condition);
extern void assume(in bool condition);
extern void oob();
extern void dontCare();
extern void do_drop();
extern mutable_packet {
    mutable_packet(int size);
    void extract<T>(out T hdr);
    void extract<T>(out T variableSizeHeader, in bit<32> variableFieldSizeInBits);
    void lookahead<T>(out T ret_);
    void advance(in bit<32> sizeInBits);
    void length(out bit<32> ret_);
    void emit<T>(in T hdr);
}

extern void copyPacket(@mutable_packet() in packet_model self, @mutable_packet() out packet_model self_out, @readonly @mutable_packet() in packet_model other);
extern void prependPacket(@mutable_packet() in packet_model self, @mutable_packet() out packet_model self_out, @readonly @mutable_packet() in packet_model other);
extern void readPacket(@mutable_packet() in packet_model self, @mutable_packet() out packet_model self_out);
extern void emptyPacket(@mutable_packet() in packet_model self, @mutable_packet() out packet_model self_out);
extern void do_send<H>(in H port, @mutable_packet() in packet_model pin, @mutable_packet() out packet_model pin_out);
enum flow_def_get_type_0__action_type_t {
    packet_type,
    NoAction_0
}

struct flow_def_get_type_0 {
    bool                               hit;
    bool                               reach;
    flow_def_get_type_0__action_type_t action_run;
    bit<1>                             packet_type__is_l3;
    @matchKind("exact") 
    bit<16>                            key_get_type_0_hdr_ethernet_etherType;
}

@controlled extern void query_get_type_0(@matchKind("exact") in bit<16> get_type_0_hdr_ethernet_etherType, out bool __ret___hit, out bool __ret___reach, out flow_def_get_type_0__action_type_t __ret___action_run, out bit<1> __ret___packet_type__is_l3, out bit<16> __ret___key_get_type_0_hdr_ethernet_etherType);
extern void end_get_type_0();
enum flow_def_fwd_1__action_type_t {
    fwd,
    NoAction_3
}

struct flow_def_fwd_1 {
    bool                          hit;
    bool                          reach;
    flow_def_fwd_1__action_type_t action_run;
    bit<9>                        fwd__port;
    @matchKind("exact") 
    bit<1>                        key_fwd_1_meta_l3_admit;
    @matchKind("exact") 
    bit<32>                       key_fwd_1_hdr_ipv4_dstAddr;
}

@controlled extern void query_fwd_1(@matchKind("exact") in bit<1> fwd_1_meta_l3_admit, @matchKind("exact") in bit<32> fwd_1_hdr_ipv4_dstAddr, out bool __ret___hit, out bool __ret___reach, out flow_def_fwd_1__action_type_t __ret___action_run, out bit<9> __ret___fwd__port, out bit<1> __ret___key_fwd_1_meta_l3_admit, out bit<32> __ret___key_fwd_1_hdr_ipv4_dstAddr);
extern void end_fwd_1();
extern void key_match(in bool condition);
extern void angelic_assert(in bool condition);
extern void bug();

#include <core.p4>

#include <v1model.p4>

typedef bit<48> macAddr_t;
typedef bit<32> ip4Addr_t;
@hdr("ethernet_t") struct ethernet_t {
    macAddr_t dstAddr;
    macAddr_t srcAddr;
    bit<16>   etherType;
    bool      valid_;
}

@hdr("ipv4_t") struct ipv4_t {
    bit<4>    version;
    bit<4>    ihl;
    bit<8>    diffserv;
    bit<16>   totalLen;
    bit<16>   identification;
    bit<3>    flags;
    bit<13>   fragOffset;
    bit<8>    ttl;
    bit<8>    protocol;
    bit<16>   hdrChecksum;
    ip4Addr_t srcAddr;
    ip4Addr_t dstAddr;
    bool      valid_;
}

@hdr("ipv6_t") struct ipv6_t {
    bit<4>   version;
    bit<8>   trafficClass;
    bit<20>  flowLabel;
    bit<16>  payloadLen;
    bit<8>   nextHdr;
    bit<8>   hopLimit;
    bit<128> srcAddr;
    bit<128> dstAddr;
    bool     valid_;
}

struct metadata {
    bit<1> l3_admit;
}

struct headers {
    ethernet_t ethernet;
    ipv4_t     ipv4;
    ipv6_t     ipv6;
}

parser MyParser(@mutable_packet() inout packet_model packet_MyParser, out headers hdr_MyParser, inout metadata meta_MyParser, inout standard_metadata_t standard_metadata_MyParser, inout error err_MyParser) {
    state parse_ipv4 {
        hdr_MyParser.ipv4.valid_ = true;
        {
            modelPop<bit<4>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.version);
        }
        {
            modelPop<bit<4>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.ihl);
        }
        {
            modelPop<bit<8>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.diffserv);
        }
        {
            modelPop<bit<16>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.totalLen);
        }
        {
            modelPop<bit<16>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.identification);
        }
        {
            modelPop<bit<3>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.flags);
        }
        {
            modelPop<bit<13>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.fragOffset);
        }
        {
            modelPop<bit<8>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.ttl);
        }
        {
            modelPop<bit<8>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.protocol);
        }
        {
            modelPop<bit<16>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.hdrChecksum);
        }
        {
            modelPop<bit<32>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.srcAddr);
        }
        {
            modelPop<bit<32>>(packet_MyParser, packet_MyParser, hdr_MyParser.ipv4.dstAddr);
        }
        transition accept;
    }
    state start {
        hdr_MyParser.ethernet.valid_ = false;
        hdr_MyParser.ipv4.valid_ = false;
        hdr_MyParser.ipv6.valid_ = false;
        hdr_MyParser.ethernet.valid_ = true;
        {
            modelPop<bit<48>>(packet_MyParser, packet_MyParser, hdr_MyParser.ethernet.dstAddr);
        }
        {
            modelPop<bit<48>>(packet_MyParser, packet_MyParser, hdr_MyParser.ethernet.srcAddr);
        }
        {
            modelPop<bit<16>>(packet_MyParser, packet_MyParser, hdr_MyParser.ethernet.etherType);
        }
        transition select(hdr_MyParser.ethernet.etherType) {
            16w0x800: parse_ipv4;
            default: accept;
        }
    }
}

control MyVerifyChecksum(inout headers hdr_MyVerifyChecksum, inout metadata meta_MyVerifyChecksum) {
    apply {
    }
}

control MyIngress(inout headers hdr_MyIngress, inout metadata meta_MyIngress, inout standard_metadata_t standard_metadata_MyIngress) {
    bool __track_egress_spec_MyIngress;
    flow_def_get_type_0 get_type_0_MyIngress;
    flow_def_fwd_1 fwd_1_MyIngress;
    flow_def_get_type_0 tmp_MyIngress;
    flow_def_fwd_1 tmp_0_MyIngress;
    apply {
        query_get_type_0(hdr_MyIngress.ethernet.etherType, tmp_MyIngress.hit, tmp_MyIngress.reach, tmp_MyIngress.action_run, tmp_MyIngress.packet_type__is_l3, tmp_MyIngress.key_get_type_0_hdr_ethernet_etherType);
        {
            get_type_0_MyIngress.hit = tmp_MyIngress.hit;
            get_type_0_MyIngress.reach = tmp_MyIngress.reach;
            get_type_0_MyIngress.action_run = tmp_MyIngress.action_run;
            get_type_0_MyIngress.packet_type__is_l3 = tmp_MyIngress.packet_type__is_l3;
            get_type_0_MyIngress.key_get_type_0_hdr_ethernet_etherType = tmp_MyIngress.key_get_type_0_hdr_ethernet_etherType;
        }
        if (get_type_0_MyIngress.hit) {
            key_match(hdr_MyIngress.ethernet.etherType == get_type_0_MyIngress.key_get_type_0_hdr_ethernet_etherType);
            if (!hdr_MyIngress.ethernet.valid_) {
                bug();
            }
        }
        if (get_type_0_MyIngress.action_run == flow_def_get_type_0__action_type_t.NoAction_0) {
            ;
        }
        else {
            if (get_type_0_MyIngress.action_run == flow_def_get_type_0__action_type_t.packet_type) {
                angelic_assert(true);
                meta_MyIngress.l3_admit = get_type_0_MyIngress.packet_type__is_l3;
            }
            else {
                ;
            }
        }
        end_get_type_0();
        query_fwd_1(meta_MyIngress.l3_admit, hdr_MyIngress.ipv4.dstAddr, tmp_0_MyIngress.hit, tmp_0_MyIngress.reach, tmp_0_MyIngress.action_run, tmp_0_MyIngress.fwd__port, tmp_0_MyIngress.key_fwd_1_meta_l3_admit, tmp_0_MyIngress.key_fwd_1_hdr_ipv4_dstAddr);
        {
            fwd_1_MyIngress.hit = tmp_0_MyIngress.hit;
            fwd_1_MyIngress.reach = tmp_0_MyIngress.reach;
            fwd_1_MyIngress.action_run = tmp_0_MyIngress.action_run;
            fwd_1_MyIngress.fwd__port = tmp_0_MyIngress.fwd__port;
            fwd_1_MyIngress.key_fwd_1_meta_l3_admit = tmp_0_MyIngress.key_fwd_1_meta_l3_admit;
            fwd_1_MyIngress.key_fwd_1_hdr_ipv4_dstAddr = tmp_0_MyIngress.key_fwd_1_hdr_ipv4_dstAddr;
        }
        if (fwd_1_MyIngress.hit) {
            key_match(meta_MyIngress.l3_admit == fwd_1_MyIngress.key_fwd_1_meta_l3_admit && hdr_MyIngress.ipv4.dstAddr == fwd_1_MyIngress.key_fwd_1_hdr_ipv4_dstAddr);
            if (!hdr_MyIngress.ipv4.valid_) {
                bug();
            }
        }
        if (fwd_1_MyIngress.action_run == flow_def_fwd_1__action_type_t.NoAction_3) {
            ;
        }
        else {
            if (fwd_1_MyIngress.action_run == flow_def_fwd_1__action_type_t.fwd) {
                angelic_assert(true);
            }
            else {
                ;
            }
        }
        end_fwd_1();
        standard_metadata_MyIngress.egress_spec = 9w511;
        __track_egress_spec_MyIngress = true;
        if (!__track_egress_spec_MyIngress) {
            bug();
        }
    }
}

control MyEgress(inout headers hdr_MyEgress, inout metadata meta_MyEgress, inout standard_metadata_t standard_metadata_MyEgress) {
    apply {
    }
}

struct tuple_0 {
    bit<4>  field;
    bit<4>  field_0;
    bit<8>  field_1;
    bit<16> field_2;
    bit<16> field_3;
    bit<3>  field_4;
    bit<13> field_5;
    bit<8>  field_6;
    bit<8>  field_7;
    bit<32> field_8;
    bit<32> field_9;
}

control MyComputeChecksum(inout headers hdr_MyComputeChecksum, inout metadata meta_MyComputeChecksum) {
    apply {
    }
}

control MyDeparser(@mutable_packet() inout packet_model packet_MyDeparser, in headers hdr_MyDeparser) {
    apply {
    }
}

V1Switch<headers, metadata>(MyParser(), MyVerifyChecksum(), MyIngress(), MyEgress(), MyComputeChecksum(), MyDeparser()) main;

void copy_field_list(in metadata from_copy_field_list, inout metadata to_copy_field_list, in standard_metadata_t smfrom_copy_field_list, inout standard_metadata_t smto_copy_field_list, in bit<16> discriminator_copy_field_list) {
}
typedef bit<9> PortId_t;
typedef bit<48> Timestamp_t;
typedef bit<16> CloneSessionId_t;
typedef bit<16> MulticastGroup_t;
typedef bit<16> EgressInstance_t;
typedef bit<3> ClassOfService_t;
typedef bit<32> PacketLength_t;
typedef bit<32> InstanceType_t;
const InstanceType_t PKT_INSTANCE_TYPE_NORMAL = 32w0;
const InstanceType_t PKT_INSTANCE_TYPE_INGRESS_CLONE = 32w1;
const InstanceType_t PKT_INSTANCE_TYPE_EGRESS_CLONE = 32w2;
const InstanceType_t PKT_INSTANCE_TYPE_RESUBMIT = 32w3;
const InstanceType_t PKT_INSTANCE_TYPE_REPLICATION = 32w4;
const InstanceType_t PKT_INSTANCE_TYPE_RECIRC = 32w5;
extern void platform_port_valid(in PortId_t p, out bool ret_);
extern void now(out Timestamp_t ret_);
extern void is_cpu_port(in PortId_t p, out bool ret_);
@controlled extern void constrain(@readonly @mutable_packet() in packet_model pin, out bool ret_);
@impl("parse_and_run_") @noreturn extern void parse_and_run(@mutable_packet() inout packet_model pin_parse_and_run, inout metadata metas__parse_and_run, inout standard_metadata_t standard_meta_parse_and_run);
@impl("PSAImpl_egress_start_") @noreturn extern void PSAImpl_egress_start(@mutable_packet() inout packet_model p_PSAImpl_egress_start, inout headers hdrs__PSAImpl_egress_start, inout metadata metas__PSAImpl_egress_start, inout standard_metadata_t standard_meta_PSAImpl_egress_start);
@impl("PSAImpl_ingress_start_") @noreturn extern void PSAImpl_ingress_start(@mutable_packet() inout packet_model p_PSAImpl_ingress_start, inout headers hdrs__PSAImpl_ingress_start, inout metadata metas__PSAImpl_ingress_start, inout standard_metadata_t standard_meta_PSAImpl_ingress_start);
extern void zero_out<T>(in T x, out T x_out);
struct clone_session_t {
    bool             exists;
    PortId_t         port;
    EgressInstance_t instance;
}

struct clone_session_properties_t {
    bool             exists;
    ClassOfService_t class_of_service;
    bool             trunc;
    PacketLength_t   plen;
}

@controlled extern void qquery_first_clone_pre(in CloneSessionId_t cs, out bool __ret___exists, out bit<9> __ret___port, out bit<16> __ret___instance);
@controlled extern void qquery_all_clone_pre(in CloneSessionId_t cs, out bool __ret___exists, out bit<9> __ret___port, out bit<16> __ret___instance);
@controlled extern void qquery_first_mcast(in MulticastGroup_t cs, out bool __ret___exists, out bit<9> __ret___port, out bit<16> __ret___instance);
@controlled extern void qquery_clone_session_properties(in CloneSessionId_t cs, out bool __ret___exists, out bit<3> __ret___class_of_service, out bool __ret___trunc, out bit<32> __ret___plen);
void PSAImpl_egress_start_(@mutable_packet() inout packet_model p_PSAImpl_egress_start, inout headers hdrs__PSAImpl_egress_start, inout metadata metas__PSAImpl_egress_start, inout standard_metadata_t standard_meta_PSAImpl_egress_start) {
    headers clone_hdrs_PSAImpl_egress_start;
    metadata clone_metas_PSAImpl_egress_start;
    standard_metadata_t clone_sm_PSAImpl_egress_start;
    CloneSessionId_t clone_session_PSAImpl_egress_start;
    CloneSessionId_t clone_field_list_PSAImpl_egress_start;
    clone_session_t cs_2_PSAImpl_egress_start;
    bit<32> recirculate_flag_1_PSAImpl_egress_start;
    bool tmp;
    MyEgress() eg;
    ;
    MyDeparser() dep;
    ;
    {
        clone_sm_PSAImpl_egress_start.ingress_port = standard_meta_PSAImpl_egress_start.ingress_port;
        clone_sm_PSAImpl_egress_start.egress_spec = standard_meta_PSAImpl_egress_start.egress_spec;
        clone_sm_PSAImpl_egress_start.egress_port = standard_meta_PSAImpl_egress_start.egress_port;
        clone_sm_PSAImpl_egress_start.clone_spec = standard_meta_PSAImpl_egress_start.clone_spec;
        clone_sm_PSAImpl_egress_start.instance_type = standard_meta_PSAImpl_egress_start.instance_type;
        clone_sm_PSAImpl_egress_start.drop = standard_meta_PSAImpl_egress_start.drop;
        clone_sm_PSAImpl_egress_start.recirculate_port = standard_meta_PSAImpl_egress_start.recirculate_port;
        clone_sm_PSAImpl_egress_start.packet_length = standard_meta_PSAImpl_egress_start.packet_length;
        clone_sm_PSAImpl_egress_start.enq_timestamp = standard_meta_PSAImpl_egress_start.enq_timestamp;
        clone_sm_PSAImpl_egress_start.enq_qdepth = standard_meta_PSAImpl_egress_start.enq_qdepth;
        clone_sm_PSAImpl_egress_start.deq_timedelta = standard_meta_PSAImpl_egress_start.deq_timedelta;
        clone_sm_PSAImpl_egress_start.deq_qdepth = standard_meta_PSAImpl_egress_start.deq_qdepth;
        clone_sm_PSAImpl_egress_start.ingress_global_timestamp = standard_meta_PSAImpl_egress_start.ingress_global_timestamp;
        clone_sm_PSAImpl_egress_start.egress_global_timestamp = standard_meta_PSAImpl_egress_start.egress_global_timestamp;
        clone_sm_PSAImpl_egress_start.lf_field_list = standard_meta_PSAImpl_egress_start.lf_field_list;
        clone_sm_PSAImpl_egress_start.mcast_grp = standard_meta_PSAImpl_egress_start.mcast_grp;
        clone_sm_PSAImpl_egress_start.resubmit_flag = standard_meta_PSAImpl_egress_start.resubmit_flag;
        clone_sm_PSAImpl_egress_start.egress_rid = standard_meta_PSAImpl_egress_start.egress_rid;
        clone_sm_PSAImpl_egress_start.recirculate_flag = standard_meta_PSAImpl_egress_start.recirculate_flag;
        clone_sm_PSAImpl_egress_start.checksum_error = standard_meta_PSAImpl_egress_start.checksum_error;
        clone_sm_PSAImpl_egress_start.parser_error = standard_meta_PSAImpl_egress_start.parser_error;
        clone_sm_PSAImpl_egress_start.priority = standard_meta_PSAImpl_egress_start.priority;
        clone_sm_PSAImpl_egress_start.deflection_flag = standard_meta_PSAImpl_egress_start.deflection_flag;
        clone_sm_PSAImpl_egress_start.deflect_on_drop = standard_meta_PSAImpl_egress_start.deflect_on_drop;
        clone_sm_PSAImpl_egress_start.enq_congest_stat = standard_meta_PSAImpl_egress_start.enq_congest_stat;
        clone_sm_PSAImpl_egress_start.deq_congest_stat = standard_meta_PSAImpl_egress_start.deq_congest_stat;
        clone_sm_PSAImpl_egress_start.mcast_hash = standard_meta_PSAImpl_egress_start.mcast_hash;
        clone_sm_PSAImpl_egress_start.ingress_cos = standard_meta_PSAImpl_egress_start.ingress_cos;
        clone_sm_PSAImpl_egress_start.packet_color = standard_meta_PSAImpl_egress_start.packet_color;
        clone_sm_PSAImpl_egress_start.qid = standard_meta_PSAImpl_egress_start.qid;
    }
    {
        clone_hdrs_PSAImpl_egress_start.ethernet.dstAddr = hdrs__PSAImpl_egress_start.ethernet.dstAddr;
        clone_hdrs_PSAImpl_egress_start.ethernet.srcAddr = hdrs__PSAImpl_egress_start.ethernet.srcAddr;
        clone_hdrs_PSAImpl_egress_start.ethernet.etherType = hdrs__PSAImpl_egress_start.ethernet.etherType;
        clone_hdrs_PSAImpl_egress_start.ethernet.valid_ = hdrs__PSAImpl_egress_start.ethernet.valid_;
        clone_hdrs_PSAImpl_egress_start.ipv4.version = hdrs__PSAImpl_egress_start.ipv4.version;
        clone_hdrs_PSAImpl_egress_start.ipv4.ihl = hdrs__PSAImpl_egress_start.ipv4.ihl;
        clone_hdrs_PSAImpl_egress_start.ipv4.diffserv = hdrs__PSAImpl_egress_start.ipv4.diffserv;
        clone_hdrs_PSAImpl_egress_start.ipv4.totalLen = hdrs__PSAImpl_egress_start.ipv4.totalLen;
        clone_hdrs_PSAImpl_egress_start.ipv4.identification = hdrs__PSAImpl_egress_start.ipv4.identification;
        clone_hdrs_PSAImpl_egress_start.ipv4.flags = hdrs__PSAImpl_egress_start.ipv4.flags;
        clone_hdrs_PSAImpl_egress_start.ipv4.fragOffset = hdrs__PSAImpl_egress_start.ipv4.fragOffset;
        clone_hdrs_PSAImpl_egress_start.ipv4.ttl = hdrs__PSAImpl_egress_start.ipv4.ttl;
        clone_hdrs_PSAImpl_egress_start.ipv4.protocol = hdrs__PSAImpl_egress_start.ipv4.protocol;
        clone_hdrs_PSAImpl_egress_start.ipv4.hdrChecksum = hdrs__PSAImpl_egress_start.ipv4.hdrChecksum;
        clone_hdrs_PSAImpl_egress_start.ipv4.srcAddr = hdrs__PSAImpl_egress_start.ipv4.srcAddr;
        clone_hdrs_PSAImpl_egress_start.ipv4.dstAddr = hdrs__PSAImpl_egress_start.ipv4.dstAddr;
        clone_hdrs_PSAImpl_egress_start.ipv4.valid_ = hdrs__PSAImpl_egress_start.ipv4.valid_;
        clone_hdrs_PSAImpl_egress_start.ipv6.version = hdrs__PSAImpl_egress_start.ipv6.version;
        clone_hdrs_PSAImpl_egress_start.ipv6.trafficClass = hdrs__PSAImpl_egress_start.ipv6.trafficClass;
        clone_hdrs_PSAImpl_egress_start.ipv6.flowLabel = hdrs__PSAImpl_egress_start.ipv6.flowLabel;
        clone_hdrs_PSAImpl_egress_start.ipv6.payloadLen = hdrs__PSAImpl_egress_start.ipv6.payloadLen;
        clone_hdrs_PSAImpl_egress_start.ipv6.nextHdr = hdrs__PSAImpl_egress_start.ipv6.nextHdr;
        clone_hdrs_PSAImpl_egress_start.ipv6.hopLimit = hdrs__PSAImpl_egress_start.ipv6.hopLimit;
        clone_hdrs_PSAImpl_egress_start.ipv6.srcAddr = hdrs__PSAImpl_egress_start.ipv6.srcAddr;
        clone_hdrs_PSAImpl_egress_start.ipv6.dstAddr = hdrs__PSAImpl_egress_start.ipv6.dstAddr;
        clone_hdrs_PSAImpl_egress_start.ipv6.valid_ = hdrs__PSAImpl_egress_start.ipv6.valid_;
    }
    {
        clone_metas_PSAImpl_egress_start.l3_admit = metas__PSAImpl_egress_start.l3_admit;
    }
    eg.apply(hdrs__PSAImpl_egress_start, metas__PSAImpl_egress_start, standard_meta_PSAImpl_egress_start);
    clone_session_PSAImpl_egress_start = standard_meta_PSAImpl_egress_start.clone_spec[15:0];
    clone_field_list_PSAImpl_egress_start = standard_meta_PSAImpl_egress_start.clone_spec[31:16];
    if (clone_session_PSAImpl_egress_start != 16w0) {
        qquery_first_clone_pre(clone_session_PSAImpl_egress_start, cs_2_PSAImpl_egress_start.exists, cs_2_PSAImpl_egress_start.port, cs_2_PSAImpl_egress_start.instance);
        copy_field_list(metas__PSAImpl_egress_start, clone_metas_PSAImpl_egress_start, standard_meta_PSAImpl_egress_start, clone_sm_PSAImpl_egress_start, (bit<16>)clone_field_list_PSAImpl_egress_start);
        clone_sm_PSAImpl_egress_start.instance_type = 32w2;
        clone_sm_PSAImpl_egress_start.egress_port = cs_2_PSAImpl_egress_start.port;
        clone_sm_PSAImpl_egress_start.resubmit_flag = (bit<32>)32w0;
        clone_sm_PSAImpl_egress_start.clone_spec = (bit<32>)32w0;
        havoc<bool>(tmp);
        if (tmp) {
            PSAImpl_egress_start(p_PSAImpl_egress_start, clone_hdrs_PSAImpl_egress_start, clone_metas_PSAImpl_egress_start, clone_sm_PSAImpl_egress_start);
        }
    }
    if (standard_meta_PSAImpl_egress_start.egress_spec == 9w511) {
        do_drop();
    }
    dep.apply(p_PSAImpl_egress_start, hdrs__PSAImpl_egress_start);
    recirculate_flag_1_PSAImpl_egress_start = standard_meta_PSAImpl_egress_start.recirculate_flag;
    if (recirculate_flag_1_PSAImpl_egress_start != 32w0) {
        {
            clone_metas_PSAImpl_egress_start.l3_admit = 1w0;
        }
        copy_field_list(metas__PSAImpl_egress_start, clone_metas_PSAImpl_egress_start, standard_meta_PSAImpl_egress_start, clone_sm_PSAImpl_egress_start, (bit<16>)recirculate_flag_1_PSAImpl_egress_start);
        clone_sm_PSAImpl_egress_start.resubmit_flag = (bit<32>)32w0;
        clone_sm_PSAImpl_egress_start.clone_spec = (bit<32>)32w0;
        clone_sm_PSAImpl_egress_start.recirculate_flag = (bit<32>)32w0;
        clone_sm_PSAImpl_egress_start.egress_spec = (bit<9>)9w0;
        clone_sm_PSAImpl_egress_start.egress_port = (bit<9>)9w0;
        clone_sm_PSAImpl_egress_start.instance_type = 32w5;
        copy_field_list(metas__PSAImpl_egress_start, clone_metas_PSAImpl_egress_start, standard_meta_PSAImpl_egress_start, clone_sm_PSAImpl_egress_start, (bit<16>)recirculate_flag_1_PSAImpl_egress_start);
        parse_and_run(p_PSAImpl_egress_start, clone_metas_PSAImpl_egress_start, clone_sm_PSAImpl_egress_start);
    }
    do_send<bit<9>>(standard_meta_PSAImpl_egress_start.egress_port, p_PSAImpl_egress_start, p_PSAImpl_egress_start);
}
void PSAImpl_ingress_start_(@mutable_packet() inout packet_model p_PSAImpl_ingress_start, inout headers hdrs__PSAImpl_ingress_start, inout metadata metas__PSAImpl_ingress_start, inout standard_metadata_t standard_meta_PSAImpl_ingress_start) {
    headers clone_hdrs_2_PSAImpl_ingress_start;
    metadata clone_metas_2_PSAImpl_ingress_start;
    standard_metadata_t clone_sm_2_PSAImpl_ingress_start;
    CloneSessionId_t clone_session_2_PSAImpl_ingress_start;
    CloneSessionId_t clone_field_list_2_PSAImpl_ingress_start;
    MulticastGroup_t mgid_PSAImpl_ingress_start;
    bit<32> resubmit_flag_1_PSAImpl_ingress_start;
    clone_session_t cs_3_PSAImpl_ingress_start;
    clone_session_t ms_PSAImpl_ingress_start;
    bool tmp_0;
    MyIngress() ig;
    ;
    {
        clone_sm_2_PSAImpl_ingress_start.ingress_port = standard_meta_PSAImpl_ingress_start.ingress_port;
        clone_sm_2_PSAImpl_ingress_start.egress_spec = standard_meta_PSAImpl_ingress_start.egress_spec;
        clone_sm_2_PSAImpl_ingress_start.egress_port = standard_meta_PSAImpl_ingress_start.egress_port;
        clone_sm_2_PSAImpl_ingress_start.clone_spec = standard_meta_PSAImpl_ingress_start.clone_spec;
        clone_sm_2_PSAImpl_ingress_start.instance_type = standard_meta_PSAImpl_ingress_start.instance_type;
        clone_sm_2_PSAImpl_ingress_start.drop = standard_meta_PSAImpl_ingress_start.drop;
        clone_sm_2_PSAImpl_ingress_start.recirculate_port = standard_meta_PSAImpl_ingress_start.recirculate_port;
        clone_sm_2_PSAImpl_ingress_start.packet_length = standard_meta_PSAImpl_ingress_start.packet_length;
        clone_sm_2_PSAImpl_ingress_start.enq_timestamp = standard_meta_PSAImpl_ingress_start.enq_timestamp;
        clone_sm_2_PSAImpl_ingress_start.enq_qdepth = standard_meta_PSAImpl_ingress_start.enq_qdepth;
        clone_sm_2_PSAImpl_ingress_start.deq_timedelta = standard_meta_PSAImpl_ingress_start.deq_timedelta;
        clone_sm_2_PSAImpl_ingress_start.deq_qdepth = standard_meta_PSAImpl_ingress_start.deq_qdepth;
        clone_sm_2_PSAImpl_ingress_start.ingress_global_timestamp = standard_meta_PSAImpl_ingress_start.ingress_global_timestamp;
        clone_sm_2_PSAImpl_ingress_start.egress_global_timestamp = standard_meta_PSAImpl_ingress_start.egress_global_timestamp;
        clone_sm_2_PSAImpl_ingress_start.lf_field_list = standard_meta_PSAImpl_ingress_start.lf_field_list;
        clone_sm_2_PSAImpl_ingress_start.mcast_grp = standard_meta_PSAImpl_ingress_start.mcast_grp;
        clone_sm_2_PSAImpl_ingress_start.resubmit_flag = standard_meta_PSAImpl_ingress_start.resubmit_flag;
        clone_sm_2_PSAImpl_ingress_start.egress_rid = standard_meta_PSAImpl_ingress_start.egress_rid;
        clone_sm_2_PSAImpl_ingress_start.recirculate_flag = standard_meta_PSAImpl_ingress_start.recirculate_flag;
        clone_sm_2_PSAImpl_ingress_start.checksum_error = standard_meta_PSAImpl_ingress_start.checksum_error;
        clone_sm_2_PSAImpl_ingress_start.parser_error = standard_meta_PSAImpl_ingress_start.parser_error;
        clone_sm_2_PSAImpl_ingress_start.priority = standard_meta_PSAImpl_ingress_start.priority;
        clone_sm_2_PSAImpl_ingress_start.deflection_flag = standard_meta_PSAImpl_ingress_start.deflection_flag;
        clone_sm_2_PSAImpl_ingress_start.deflect_on_drop = standard_meta_PSAImpl_ingress_start.deflect_on_drop;
        clone_sm_2_PSAImpl_ingress_start.enq_congest_stat = standard_meta_PSAImpl_ingress_start.enq_congest_stat;
        clone_sm_2_PSAImpl_ingress_start.deq_congest_stat = standard_meta_PSAImpl_ingress_start.deq_congest_stat;
        clone_sm_2_PSAImpl_ingress_start.mcast_hash = standard_meta_PSAImpl_ingress_start.mcast_hash;
        clone_sm_2_PSAImpl_ingress_start.ingress_cos = standard_meta_PSAImpl_ingress_start.ingress_cos;
        clone_sm_2_PSAImpl_ingress_start.packet_color = standard_meta_PSAImpl_ingress_start.packet_color;
        clone_sm_2_PSAImpl_ingress_start.qid = standard_meta_PSAImpl_ingress_start.qid;
    }
    {
        clone_hdrs_2_PSAImpl_ingress_start.ethernet.dstAddr = hdrs__PSAImpl_ingress_start.ethernet.dstAddr;
        clone_hdrs_2_PSAImpl_ingress_start.ethernet.srcAddr = hdrs__PSAImpl_ingress_start.ethernet.srcAddr;
        clone_hdrs_2_PSAImpl_ingress_start.ethernet.etherType = hdrs__PSAImpl_ingress_start.ethernet.etherType;
        clone_hdrs_2_PSAImpl_ingress_start.ethernet.valid_ = hdrs__PSAImpl_ingress_start.ethernet.valid_;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.version = hdrs__PSAImpl_ingress_start.ipv4.version;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.ihl = hdrs__PSAImpl_ingress_start.ipv4.ihl;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.diffserv = hdrs__PSAImpl_ingress_start.ipv4.diffserv;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.totalLen = hdrs__PSAImpl_ingress_start.ipv4.totalLen;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.identification = hdrs__PSAImpl_ingress_start.ipv4.identification;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.flags = hdrs__PSAImpl_ingress_start.ipv4.flags;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.fragOffset = hdrs__PSAImpl_ingress_start.ipv4.fragOffset;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.ttl = hdrs__PSAImpl_ingress_start.ipv4.ttl;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.protocol = hdrs__PSAImpl_ingress_start.ipv4.protocol;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.hdrChecksum = hdrs__PSAImpl_ingress_start.ipv4.hdrChecksum;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.srcAddr = hdrs__PSAImpl_ingress_start.ipv4.srcAddr;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.dstAddr = hdrs__PSAImpl_ingress_start.ipv4.dstAddr;
        clone_hdrs_2_PSAImpl_ingress_start.ipv4.valid_ = hdrs__PSAImpl_ingress_start.ipv4.valid_;
        clone_hdrs_2_PSAImpl_ingress_start.ipv6.version = hdrs__PSAImpl_ingress_start.ipv6.version;
        clone_hdrs_2_PSAImpl_ingress_start.ipv6.trafficClass = hdrs__PSAImpl_ingress_start.ipv6.trafficClass;
        clone_hdrs_2_PSAImpl_ingress_start.ipv6.flowLabel = hdrs__PSAImpl_ingress_start.ipv6.flowLabel;
        clone_hdrs_2_PSAImpl_ingress_start.ipv6.payloadLen = hdrs__PSAImpl_ingress_start.ipv6.payloadLen;
        clone_hdrs_2_PSAImpl_ingress_start.ipv6.nextHdr = hdrs__PSAImpl_ingress_start.ipv6.nextHdr;
        clone_hdrs_2_PSAImpl_ingress_start.ipv6.hopLimit = hdrs__PSAImpl_ingress_start.ipv6.hopLimit;
        clone_hdrs_2_PSAImpl_ingress_start.ipv6.srcAddr = hdrs__PSAImpl_ingress_start.ipv6.srcAddr;
        clone_hdrs_2_PSAImpl_ingress_start.ipv6.dstAddr = hdrs__PSAImpl_ingress_start.ipv6.dstAddr;
        clone_hdrs_2_PSAImpl_ingress_start.ipv6.valid_ = hdrs__PSAImpl_ingress_start.ipv6.valid_;
    }
    {
        clone_metas_2_PSAImpl_ingress_start.l3_admit = metas__PSAImpl_ingress_start.l3_admit;
    }
    ig.apply(hdrs__PSAImpl_ingress_start, metas__PSAImpl_ingress_start, standard_meta_PSAImpl_ingress_start);
    clone_session_2_PSAImpl_ingress_start = standard_meta_PSAImpl_ingress_start.clone_spec[15:0];
    clone_field_list_2_PSAImpl_ingress_start = standard_meta_PSAImpl_ingress_start.clone_spec[31:16];
    mgid_PSAImpl_ingress_start = standard_meta_PSAImpl_ingress_start.mcast_grp;
    resubmit_flag_1_PSAImpl_ingress_start = standard_meta_PSAImpl_ingress_start.resubmit_flag;
    if (clone_session_2_PSAImpl_ingress_start != 16w0) {
        qquery_first_clone_pre(clone_session_2_PSAImpl_ingress_start, cs_3_PSAImpl_ingress_start.exists, cs_3_PSAImpl_ingress_start.port, cs_3_PSAImpl_ingress_start.instance);
        copy_field_list(metas__PSAImpl_ingress_start, clone_metas_2_PSAImpl_ingress_start, standard_meta_PSAImpl_ingress_start, clone_sm_2_PSAImpl_ingress_start, (bit<16>)clone_field_list_2_PSAImpl_ingress_start);
        clone_sm_2_PSAImpl_ingress_start.egress_port = cs_3_PSAImpl_ingress_start.port;
        clone_sm_2_PSAImpl_ingress_start.resubmit_flag = (bit<32>)32w0;
        clone_sm_2_PSAImpl_ingress_start.clone_spec = (bit<32>)32w0;
        clone_sm_2_PSAImpl_ingress_start.recirculate_flag = (bit<32>)32w0;
        clone_sm_2_PSAImpl_ingress_start.egress_spec = (bit<9>)9w0;
        clone_sm_2_PSAImpl_ingress_start.egress_port = (bit<9>)9w0;
        clone_sm_2_PSAImpl_ingress_start.instance_type = 32w1;
        havoc<bool>(tmp_0);
        if (tmp_0) {
            PSAImpl_egress_start(p_PSAImpl_ingress_start, clone_hdrs_2_PSAImpl_ingress_start, clone_metas_2_PSAImpl_ingress_start, clone_sm_2_PSAImpl_ingress_start);
        }
        standard_meta_PSAImpl_ingress_start.resubmit_flag = (bit<32>)32w0;
        standard_meta_PSAImpl_ingress_start.clone_spec = (bit<32>)32w0;
        standard_meta_PSAImpl_ingress_start.recirculate_flag = (bit<32>)32w0;
    }
    if (resubmit_flag_1_PSAImpl_ingress_start != 32w0) {
        copy_field_list(metas__PSAImpl_ingress_start, clone_metas_2_PSAImpl_ingress_start, standard_meta_PSAImpl_ingress_start, clone_sm_2_PSAImpl_ingress_start, (bit<16>)resubmit_flag_1_PSAImpl_ingress_start);
        {
            clone_sm_2_PSAImpl_ingress_start.ingress_port = standard_meta_PSAImpl_ingress_start.ingress_port;
            clone_sm_2_PSAImpl_ingress_start.egress_spec = standard_meta_PSAImpl_ingress_start.egress_spec;
            clone_sm_2_PSAImpl_ingress_start.egress_port = standard_meta_PSAImpl_ingress_start.egress_port;
            clone_sm_2_PSAImpl_ingress_start.clone_spec = standard_meta_PSAImpl_ingress_start.clone_spec;
            clone_sm_2_PSAImpl_ingress_start.instance_type = standard_meta_PSAImpl_ingress_start.instance_type;
            clone_sm_2_PSAImpl_ingress_start.drop = standard_meta_PSAImpl_ingress_start.drop;
            clone_sm_2_PSAImpl_ingress_start.recirculate_port = standard_meta_PSAImpl_ingress_start.recirculate_port;
            clone_sm_2_PSAImpl_ingress_start.packet_length = standard_meta_PSAImpl_ingress_start.packet_length;
            clone_sm_2_PSAImpl_ingress_start.enq_timestamp = standard_meta_PSAImpl_ingress_start.enq_timestamp;
            clone_sm_2_PSAImpl_ingress_start.enq_qdepth = standard_meta_PSAImpl_ingress_start.enq_qdepth;
            clone_sm_2_PSAImpl_ingress_start.deq_timedelta = standard_meta_PSAImpl_ingress_start.deq_timedelta;
            clone_sm_2_PSAImpl_ingress_start.deq_qdepth = standard_meta_PSAImpl_ingress_start.deq_qdepth;
            clone_sm_2_PSAImpl_ingress_start.ingress_global_timestamp = standard_meta_PSAImpl_ingress_start.ingress_global_timestamp;
            clone_sm_2_PSAImpl_ingress_start.egress_global_timestamp = standard_meta_PSAImpl_ingress_start.egress_global_timestamp;
            clone_sm_2_PSAImpl_ingress_start.lf_field_list = standard_meta_PSAImpl_ingress_start.lf_field_list;
            clone_sm_2_PSAImpl_ingress_start.mcast_grp = standard_meta_PSAImpl_ingress_start.mcast_grp;
            clone_sm_2_PSAImpl_ingress_start.resubmit_flag = standard_meta_PSAImpl_ingress_start.resubmit_flag;
            clone_sm_2_PSAImpl_ingress_start.egress_rid = standard_meta_PSAImpl_ingress_start.egress_rid;
            clone_sm_2_PSAImpl_ingress_start.recirculate_flag = standard_meta_PSAImpl_ingress_start.recirculate_flag;
            clone_sm_2_PSAImpl_ingress_start.checksum_error = standard_meta_PSAImpl_ingress_start.checksum_error;
            clone_sm_2_PSAImpl_ingress_start.parser_error = standard_meta_PSAImpl_ingress_start.parser_error;
            clone_sm_2_PSAImpl_ingress_start.priority = standard_meta_PSAImpl_ingress_start.priority;
            clone_sm_2_PSAImpl_ingress_start.deflection_flag = standard_meta_PSAImpl_ingress_start.deflection_flag;
            clone_sm_2_PSAImpl_ingress_start.deflect_on_drop = standard_meta_PSAImpl_ingress_start.deflect_on_drop;
            clone_sm_2_PSAImpl_ingress_start.enq_congest_stat = standard_meta_PSAImpl_ingress_start.enq_congest_stat;
            clone_sm_2_PSAImpl_ingress_start.deq_congest_stat = standard_meta_PSAImpl_ingress_start.deq_congest_stat;
            clone_sm_2_PSAImpl_ingress_start.mcast_hash = standard_meta_PSAImpl_ingress_start.mcast_hash;
            clone_sm_2_PSAImpl_ingress_start.ingress_cos = standard_meta_PSAImpl_ingress_start.ingress_cos;
            clone_sm_2_PSAImpl_ingress_start.packet_color = standard_meta_PSAImpl_ingress_start.packet_color;
            clone_sm_2_PSAImpl_ingress_start.qid = standard_meta_PSAImpl_ingress_start.qid;
        }
        clone_sm_2_PSAImpl_ingress_start.resubmit_flag = (bit<32>)32w0;
        clone_sm_2_PSAImpl_ingress_start.clone_spec = (bit<32>)32w0;
        clone_sm_2_PSAImpl_ingress_start.recirculate_flag = (bit<32>)32w0;
        clone_sm_2_PSAImpl_ingress_start.egress_spec = (bit<9>)9w0;
        clone_sm_2_PSAImpl_ingress_start.egress_port = (bit<9>)9w0;
        clone_sm_2_PSAImpl_ingress_start.instance_type = 32w3;
        PSAImpl_ingress_start(p_PSAImpl_ingress_start, clone_hdrs_2_PSAImpl_ingress_start, clone_metas_2_PSAImpl_ingress_start, clone_sm_2_PSAImpl_ingress_start);
    }
    if (mgid_PSAImpl_ingress_start != 16w0) {
        standard_meta_PSAImpl_ingress_start.instance_type = 32w4;
        qquery_first_mcast(mgid_PSAImpl_ingress_start, ms_PSAImpl_ingress_start.exists, ms_PSAImpl_ingress_start.port, ms_PSAImpl_ingress_start.instance);
        standard_meta_PSAImpl_ingress_start.egress_port = ms_PSAImpl_ingress_start.port;
        standard_meta_PSAImpl_ingress_start.egress_rid = ms_PSAImpl_ingress_start.instance;
        PSAImpl_egress_start(p_PSAImpl_ingress_start, hdrs__PSAImpl_ingress_start, metas__PSAImpl_ingress_start, standard_meta_PSAImpl_ingress_start);
    }
    if (standard_meta_PSAImpl_ingress_start.egress_spec == 9w511) {
        do_drop();
    }
    standard_meta_PSAImpl_ingress_start.egress_port = standard_meta_PSAImpl_ingress_start.egress_spec;
    standard_meta_PSAImpl_ingress_start.instance_type = 32w0;
    PSAImpl_egress_start(p_PSAImpl_ingress_start, hdrs__PSAImpl_ingress_start, metas__PSAImpl_ingress_start, standard_meta_PSAImpl_ingress_start);
}
void parse_and_run_(@mutable_packet() inout packet_model pin_parse_and_run, inout metadata metas__parse_and_run, inout standard_metadata_t standard_meta_parse_and_run) {
    error last_parse_and_run;
    headers hdrs_0_parse_and_run;
    now(standard_meta_parse_and_run.ingress_global_timestamp);
    {
        hdrs_0_parse_and_run.ethernet.valid_ = false;
        hdrs_0_parse_and_run.ipv4.valid_ = false;
        hdrs_0_parse_and_run.ipv6.valid_ = false;
    }
    MyParser() p;
    ;
    last_parse_and_run = error.NoError;
    p.apply(pin_parse_and_run, hdrs_0_parse_and_run, metas__parse_and_run, standard_meta_parse_and_run, last_parse_and_run);
    standard_meta_parse_and_run.parser_error = last_parse_and_run;
    PSAImpl_ingress_start(pin_parse_and_run, hdrs_0_parse_and_run, metas__parse_and_run, standard_meta_parse_and_run);
}
void run() {
    PortId_t p_1_run;
    standard_metadata_t standard_meta_1_run;
    error last_2_run;
    metadata metas_0_run;
    @mutable_packet() packet_model pin;
    bool tmp_1;
    bool tmp_3;
    bool tmp_2;
    havoc<packet_model>(pin);
    havoc<PortId_t>(p_1_run);
    platform_port_valid(p_1_run, tmp_1);
    if (!tmp_1) {
        do_drop();
    }
    is_cpu_port(p_1_run, tmp_3);
    if (tmp_3) {
        constrain(pin, tmp_2);
        if (!tmp_2) {
            do_drop();
        }
    }
    else {
        angelic_assert(true);
    }
    {
        standard_meta_1_run.ingress_port = 9w0;
        standard_meta_1_run.egress_spec = 9w0;
        standard_meta_1_run.egress_port = 9w0;
        standard_meta_1_run.clone_spec = 32w0;
        standard_meta_1_run.instance_type = 32w0;
        standard_meta_1_run.drop = 1w0;
        standard_meta_1_run.recirculate_port = 16w0;
        standard_meta_1_run.packet_length = 32w0;
        standard_meta_1_run.enq_timestamp = 32w0;
        standard_meta_1_run.enq_qdepth = 19w0;
        standard_meta_1_run.deq_timedelta = 32w0;
        standard_meta_1_run.deq_qdepth = 19w0;
        standard_meta_1_run.ingress_global_timestamp = 48w0;
        standard_meta_1_run.egress_global_timestamp = 48w0;
        standard_meta_1_run.lf_field_list = 32w0;
        standard_meta_1_run.mcast_grp = 16w0;
        standard_meta_1_run.resubmit_flag = 32w0;
        standard_meta_1_run.egress_rid = 16w0;
        standard_meta_1_run.recirculate_flag = 32w0;
        standard_meta_1_run.checksum_error = 1w0;
        standard_meta_1_run.priority = 3w0;
        standard_meta_1_run.deflection_flag = 1w0;
        standard_meta_1_run.deflect_on_drop = 1w0;
        standard_meta_1_run.enq_congest_stat = 2w0;
        standard_meta_1_run.deq_congest_stat = 2w0;
        standard_meta_1_run.mcast_hash = 13w0;
        standard_meta_1_run.ingress_cos = 3w0;
        standard_meta_1_run.packet_color = 2w0;
        standard_meta_1_run.qid = 5w0;
    }
    standard_meta_1_run.ingress_port = p_1_run;
    now(standard_meta_1_run.ingress_global_timestamp);
    {
        metas_0_run.l3_admit = 1w0;
    }
    standard_meta_1_run.instance_type = 32w0;
    parse_and_run(pin, metas_0_run, standard_meta_1_run);
}
